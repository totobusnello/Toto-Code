/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Configuration for JJWrapper */
export interface JjConfig {
  /** Path to jj executable (default: "jj") */
  jjPath: string
  /** Repository path (default: current directory) */
  repoPath: string
  /** Timeout for operations in milliseconds */
  timeoutMs: number
  /** Enable verbose logging */
  verbose: boolean
  /** Maximum operation log entries to keep in memory */
  maxLogEntries: number
  /** Enable AgentDB sync */
  enableAgentdbSync: boolean
}
/**
 * ML-DSA signing keypair
 *
 * Contains public and secret keys for quantum-resistant digital signatures.
 */
export interface SigningKeypair {
  /** Public key (hex-encoded) */
  publicKey: string
  /** Secret key (hex-encoded) - should be kept secure */
  secretKey: string
}
/**
 * Digital signature for an operation
 *
 * Contains the signature and associated metadata.
 */
export interface OperationSignature {
  /** Signature bytes (hex-encoded) */
  signature: string
  /** Public key used for verification (hex-encoded) */
  publicKey: string
  /** Timestamp when signature was created (ISO 8601) */
  signedAt: string
  /** Algorithm identifier */
  algorithm: string
}
/**
 * Generate a new ML-DSA signing keypair
 *
 * Creates a quantum-resistant keypair for signing operations.
 *
 * # Examples
 *
 * ```rust
 * use agentic_jujutsu::crypto::generate_signing_keypair;
 *
 * let keypair = generate_signing_keypair();
 * println!("Public key: {}", keypair.public_key);
 * ```
 */
export declare function generateSigningKeypair(): SigningKeypair
/**
 * Sign a message with ML-DSA
 *
 * Creates a quantum-resistant digital signature for the given message.
 *
 * # Arguments
 *
 * * `message` - The message to sign
 * * `secret_key` - The secret key in hex format
 *
 * # Returns
 *
 * The signature bytes in hex format
 */
export declare function signMessage(message: Array<number>, secretKey: string): string
/**
 * Verify a message signature with ML-DSA
 *
 * Verifies that a signature is valid for the given message and public key.
 *
 * # Arguments
 *
 * * `message` - The message that was signed
 * * `signature` - The signature in hex format
 * * `public_key` - The public key in hex format
 *
 * # Returns
 *
 * `true` if the signature is valid, `false` otherwise
 */
export declare function verifySignature(message: Array<number>, signature: string, publicKey: string): boolean
/**
 * Type of jujutsu operation
 *
 * Represents the various operations that can be performed in a jujutsu repository.
 */
export const enum OperationType {
  /** Create a new commit */
  Commit = 0,
  /** Snapshot operation (automatic) */
  Snapshot = 1,
  /** Describe/amend commit message */
  Describe = 2,
  /** New commit creation */
  New = 3,
  /** Edit commit */
  Edit = 4,
  /** Abandon a commit */
  Abandon = 5,
  /** Rebase commits */
  Rebase = 6,
  /** Squash commits */
  Squash = 7,
  /** Resolve conflicts */
  Resolve = 8,
  /** Branch operation */
  Branch = 9,
  /** Delete a branch */
  BranchDelete = 10,
  /** Bookmark operation */
  Bookmark = 11,
  /** Create a tag */
  Tag = 12,
  /** Checkout a commit */
  Checkout = 13,
  /** Restore files */
  Restore = 14,
  /** Split a commit */
  Split = 15,
  /** Duplicate a commit */
  Duplicate = 16,
  /** Undo last operation */
  Undo = 17,
  /** Fetch from remote */
  Fetch = 18,
  /** Git fetch */
  GitFetch = 19,
  /** Push to remote */
  Push = 20,
  /** Git push */
  GitPush = 21,
  /** Clone repository */
  Clone = 22,
  /** Initialize repository */
  Init = 23,
  /** Git import */
  GitImport = 24,
  /** Git export */
  GitExport = 25,
  /** Move changes */
  Move = 26,
  /** Diffedit */
  Diffedit = 27,
  /** Merge branches */
  Merge = 28,
  /** Show status */
  Status = 29,
  /** Show commit log */
  Log = 30,
  /** Show diff */
  Diff = 31,
  /** Unknown operation type */
  Unknown = 32
}
/**
 * Single jujutsu operation
 *
 * Represents a single operation in the jujutsu operation log with metadata.
 *
 * # Examples
 *
 * ```rust
 * use agentic_jujutsu::operations::{JJOperation, OperationType};
 *
 * let op = JJOperation::builder()
 *     .operation_type(OperationType::Commit)
 *     .command("jj commit".to_string())
 *     .user("alice".to_string())
 *     .build();
 * ```
 */
export interface JjOperation {
  /** Unique operation ID (generated by wrapper) */
  id: string
  /** Operation ID from jj (e.g., "abc123@example.com") */
  operationId: string
  /** Operation type (as string for N-API compatibility) */
  operationType: string
  /** Command that created this operation */
  command: string
  /** User who performed the operation */
  user: string
  /** Hostname where operation was performed */
  hostname: string
  /** Operation timestamp (ISO 8601 format) */
  timestamp: string
  /** Tags associated with this operation */
  tags: Array<string>
  /** Additional metadata (JSON string for N-API compatibility) */
  metadata: string
  /** Parent operation ID */
  parentId?: string
  /** Duration in milliseconds */
  durationMs: number
  /** Whether this operation was successful */
  success: boolean
  /** Error message (if failed) */
  error?: string
  /** Quantum fingerprint for fast integrity verification (hex string) */
  quantumFingerprint?: string
  /** Digital signature (hex-encoded, optional) */
  signature?: string
  /** Public key used for signature verification (hex-encoded, optional) */
  signaturePublicKey?: string
}
/**
 * Quantum-resistant signing keypair (ML-DSA-65)
 *
 * This structure holds both the public and secret keys for ML-DSA signing.
 * Keys are stored as base64-encoded strings for JSON serialization.
 *
 * # Security Notes
 *
 * - Secret keys should be stored securely (encrypted at rest)
 * - Use key rotation policies (recommend rotation every 90 days)
 * - Never commit secret keys to version control
 * - Consider hardware security modules (HSM) for production
 */
export interface SigningKeypair {
  /** Base64-encoded ML-DSA-65 public key (~1,952 bytes) */
  publicKey: string
  /**
   * Base64-encoded ML-DSA-65 secret key (~4,032 bytes)
   * SECURITY: Handle with extreme care
   */
  secretKey: string
  /** Key generation timestamp (ISO 8601) */
  createdAt: string
  /** Key identifier (SHA-256 hash of public key, first 16 chars) */
  keyId: string
  /** Algorithm identifier */
  algorithm: string
}
/**
 * Quantum-resistant commit signature
 *
 * This structure represents a signed commit with ML-DSA signature and metadata.
 *
 * # Verification
 *
 * To verify a signature:
 * 1. Reconstruct commit data from commit_id and metadata
 * 2. Verify signature using public key
 * 3. Check timestamp is reasonable (not too old/future)
 */
export interface CommitSignature {
  /** Commit ID that was signed */
  commitId: string
  /** Base64-encoded ML-DSA-65 signature (~3,309 bytes) */
  signature: string
  /** Key ID used for signing (references SigningKeypair.key_id) */
  keyId: string
  /** Signature timestamp (ISO 8601) */
  signedAt: string
  /** Algorithm identifier */
  algorithm: string
  /** Additional metadata signed with commit */
  metadata: Record<string, string>
}
/**
 * Result wrapper for jujutsu operations
 *
 * This type extends the basic command result with metadata about execution,
 * warnings, and structured data.
 *
 * # Examples
 *
 * ```rust
 * use agentic_jujutsu::types::JJResult;
 *
 * let result = JJResult::new("output".to_string(), "".to_string(), 0, 100);
 * assert!(result.success());
 * ```
 */
export interface JjResult {
  /** Standard output from the command */
  stdout: string
  /** Standard error from the command */
  stderr: string
  /** Exit code */
  exitCode: number
  /** Command execution time in milliseconds */
  executionTimeMs: number
}
/**
 * Commit metadata
 *
 * Represents a single commit in the jujutsu repository with all associated metadata.
 *
 * # Examples
 *
 * ```rust
 * use agentic_jujutsu::types::JJCommit;
 *
 * let commit = JJCommit::builder()
 *     .id("abc123".to_string())
 *     .message("Add new feature".to_string())
 *     .author("Bob".to_string())
 *     .build();
 *
 * assert_eq!(commit.message, "Add new feature");
 * ```
 */
export interface JjCommit {
  /** Commit ID (revision hash) */
  id: string
  /** Change ID (unique identifier for the change) */
  changeId: string
  /** Commit message */
  message: string
  /** Author name */
  author: string
  /** Author email */
  authorEmail: string
  /** Timestamp (ISO 8601 format) */
  timestamp: string
  /** Parent commit IDs */
  parents: Array<string>
  /** Child commit IDs */
  children: Array<string>
  /** Branches pointing to this commit */
  branches: Array<string>
  /** Tags associated with this commit */
  tags: Array<string>
  /** Whether this is a merge commit */
  isMerge: boolean
  /** Whether this commit has conflicts */
  hasConflicts: boolean
  /** Whether this is an empty commit */
  isEmpty: boolean
}
/**
 * Branch information
 *
 * Represents a branch in the jujutsu repository.
 *
 * # Examples
 *
 * ```rust
 * use agentic_jujutsu::types::JJBranch;
 *
 * let branch = JJBranch::new("feature/new-api".to_string(), "def456".to_string(), false);
 * assert_eq!(branch.name, "feature/new-api");
 * ```
 */
export interface JjBranch {
  /** Branch name */
  name: string
  /** Commit ID this branch points to */
  target: string
  /** Whether this is a remote branch */
  isRemote: boolean
  /** Remote name (if remote branch) */
  remote?: string
  /** Whether this branch is tracking a remote */
  isTracking: boolean
  /** Whether this is the current branch */
  isCurrent: boolean
  /** Creation timestamp (ISO 8601 format) */
  createdAt: string
}
/**
 * Conflict representation
 *
 * Represents a merge conflict with detailed information about conflicting sides.
 *
 * # Examples
 *
 * ```rust
 * use agentic_jujutsu::types::JJConflict;
 *
 * let conflict = JJConflict::builder()
 *     .path("src/main.rs".to_string())
 *     .num_conflicts(1)
 *     .conflict_type("content".to_string())
 *     .build();
 * ```
 */
export interface JjConflict {
  /** Unique conflict identifier */
  id: string
  /** Path to the conflicted file */
  path: string
  /** Number of conflict markers */
  numConflicts: number
  /** Sides involved in the conflict */
  sides: Array<string>
  /** Conflict type (e.g., "content", "modify/delete") */
  conflictType: string
  /** Whether conflict is binary (non-text) */
  isBinary: boolean
  /** Whether conflict is resolved */
  isResolved: boolean
  /** Resolution strategy used (if resolved) */
  resolutionStrategy?: string
}
/** Represents a diff between two commits */
export interface JjDiff {
  /** Files added */
  added: Array<string>
  /** Files modified */
  modified: Array<string>
  /** Files deleted */
  deleted: Array<string>
  /** Files renamed (serialized as "old_path:new_path") */
  renamed: Array<string>
  /** Total number of additions */
  additions: number
  /** Total number of deletions */
  deletions: number
  /** Diff content (unified diff format) */
  content: string
}
/**
 * Working copy change
 *
 * Represents a change in the working copy that hasn't been committed yet.
 *
 * # Examples
 *
 * ```rust
 * use agentic_jujutsu::types::{JJChange, ChangeStatus};
 *
 * let change = JJChange::new("src/main.rs".to_string());
 * ```
 */
export interface JjChange {
  /** File path */
  filePath: string
  /** Change status */
  status: ChangeStatus
  /** Whether file is staged */
  isStaged: boolean
  /** Size in bytes (if applicable) - using f64 for N-API compatibility with large numbers */
  sizeBytes?: number
}
/** Status of a file change */
export const enum ChangeStatus {
  /** File added */
  Added = 'Added',
  /** File modified */
  Modified = 'Modified',
  /** File deleted */
  Deleted = 'Deleted',
  /** File renamed (old path stored separately in JJChange) */
  Renamed = 'Renamed',
  /** File conflicted */
  Conflicted = 'Conflicted',
  /** File type changed */
  TypeChanged = 'TypeChanged'
}
/**
 * Main quantum signing interface
 *
 * Provides methods for generating keypairs, signing commits, and verifying signatures
 * using ML-DSA-65 post-quantum cryptography.
 */
export declare class QuantumSigner {
  /**
   * Generate a new ML-DSA-65 signing keypair
   *
   * This uses the @qudag/napi-core library to generate quantum-resistant keys.
   *
   * # Performance
   *
   * - Average: ~2.1ms
   * - Uses secure random number generation
   *
   * # Returns
   *
   * A new `SigningKeypair` with ML-DSA-65 keys
   *
   * # Examples
   *
   * ```javascript
   * const { QuantumSigner } = require('agentic-jujutsu');
   * const keypair = QuantumSigner.generateKeypair();
   * console.log('Key ID:', keypair.keyId);
   * ```
   */
  static generateKeypair(): SigningKeypair
  /**
   * Sign a commit with ML-DSA-65 quantum-resistant signature
   *
   * Creates a cryptographic signature over the commit ID and optional metadata.
   * The signature is tamper-proof and quantum-resistant.
   *
   * # Parameters
   *
   * - `commit_id`: The Jujutsu commit ID to sign
   * - `secret_key`: Base64-encoded ML-DSA-65 secret key
   * - `metadata`: Optional additional data to include in signature
   *
   * # Returns
   *
   * A `CommitSignature` containing the signature and metadata
   *
   * # Performance
   *
   * - Average: ~1.3ms per signature
   *
   * # Security
   *
   * - Uses deterministic signing (same input = same signature)
   * - Includes timestamp to prevent replay attacks
   * - Binds metadata to signature
   *
   * # Examples
   *
   * ```javascript
   * const signature = QuantumSigner.signCommit(
   *   'abc123',
   *   keypair.secretKey,
   *   { author: 'alice', repo: 'my-project' }
   * );
   * ```
   */
  static signCommit(commitId: string, secretKey: string, metadata?: Record<string, string> | undefined | null): CommitSignature
  /**
   * Verify a commit signature using ML-DSA-65
   *
   * Verifies that a signature is valid for the given commit and public key.
   * Returns true if the signature is cryptographically valid and the commit
   * has not been tampered with.
   *
   * # Parameters
   *
   * - `commit_id`: The commit ID that was signed
   * - `signature_data`: The `CommitSignature` to verify
   * - `public_key`: Base64-encoded ML-DSA-65 public key
   *
   * # Returns
   *
   * - `true`: Signature is valid
   * - `false`: Signature is invalid or commit was tampered
   *
   * # Performance
   *
   * - Average: ~0.85ms per verification
   *
   * # Examples
   *
   * ```javascript
   * const isValid = QuantumSigner.verifyCommit(
   *   'abc123',
   *   signature,
   *   keypair.publicKey
   * );
   * if (!isValid) {
   *   throw new Error('Commit signature verification failed!');
   * }
   * ```
   */
  static verifyCommit(commitId: string, signatureData: CommitSignature, publicKey: string): boolean
  /**
   * Export a public key in PEM format
   *
   * Converts a base64-encoded public key to PEM format for compatibility
   * with other tools and systems.
   *
   * # Parameters
   *
   * - `public_key`: Base64-encoded ML-DSA-65 public key
   *
   * # Returns
   *
   * PEM-encoded public key string
   */
  static exportPublicKeyPem(publicKey: string): string
  /**
   * Import a public key from PEM format
   *
   * Parses a PEM-encoded ML-DSA-65 public key into base64 format.
   *
   * # Parameters
   *
   * - `pem`: PEM-encoded public key
   *
   * # Returns
   *
   * Base64-encoded public key
   */
  static importPublicKeyPem(pem: string): string
  /**
   * Get signature statistics
   *
   * Returns information about ML-DSA-65 algorithm characteristics.
   *
   * # Returns
   *
   * JSON string with algorithm statistics
   */
  static getAlgorithmInfo(): string
}
export type JJWrapper = JjWrapper
/** Main wrapper for Jujutsu operations */
export declare class JjWrapper {
  /** Create a new JJWrapper with default configuration */
  constructor()
  /** Create a new JJWrapper with custom configuration */
  static withConfig(config: JjConfig): JjWrapper
  /** Get the current configuration */
  getConfig(): JjConfig
  /** Get operation log statistics as JSON string */
  getStats(): string
  /** Execute a jj command and return the result */
  execute(args: Array<string>): Promise<JjResult>
  /** Get operations from the operation log */
  getOperations(limit: number): Array<JjOperation>
  /** Get user-initiated operations (exclude snapshots) */
  getUserOperations(limit: number): Array<JjOperation>
  /** Get conflicts in the current commit or specified commit */
  getConflicts(commit?: string | undefined | null): Promise<Array<JjConflict>>
  /** Describe the current commit with a message */
  describe(message: string): Promise<JjOperation>
  /** Get repository status */
  status(): Promise<JjResult>
  /** Get diff between two commits */
  diff(from: string, to: string): Promise<JjDiff>
  /** Create a new commit (renamed from 'new' to avoid confusion with constructor) */
  newCommit(message?: string | undefined | null): Promise<JjResult>
  /** Edit a commit */
  edit(revision: string): Promise<JjResult>
  /** Abandon a commit */
  abandon(revision: string): Promise<JjResult>
  /** Squash commits */
  squash(from?: string | undefined | null, to?: string | undefined | null): Promise<JjResult>
  /** Rebase commits */
  rebase(source: string, destination: string): Promise<JjResult>
  /** Resolve conflicts */
  resolve(path?: string | undefined | null): Promise<JjResult>
  /** Create a branch */
  branchCreate(name: string, revision?: string | undefined | null): Promise<JjResult>
  /** Delete a branch */
  branchDelete(name: string): Promise<JjResult>
  /** List branches */
  branchList(): Promise<Array<JjBranch>>
  /** Undo the last operation */
  undo(): Promise<JjResult>
  /** Restore files */
  restore(paths: Array<string>): Promise<JjResult>
  /** Show commit log */
  log(limit?: number | undefined | null): Promise<Array<JjCommit>>
  /** Clear operation log */
  clearLog(): void
  /** Start a learning trajectory for a task */
  startTrajectory(task: string): string
  /** Add current operations to the active trajectory */
  addToTrajectory(): void
  /** Finalize trajectory with success score and store it */
  finalizeTrajectory(successScore: number, critique?: string | undefined | null): void
  /** Get decision suggestion from reasoning bank */
  getSuggestion(task: string): string
  /** Get learning statistics from reasoning bank */
  getLearningStats(): string
  /** Get all discovered patterns */
  getPatterns(): string
  /**
   * Enable quantum-resistant encryption for ReasoningBank trajectory storage
   *
   * Uses HQC-128 encryption from @qudag/napi-core for quantum-resistant security
   *
   * # Arguments
   * * `encryption_key` - Base64-encoded encryption key (32 bytes)
   * * `public_key` - Optional base64-encoded public key for HQC
   *
   * # Example
   * ```javascript
   * const crypto = require('crypto');
   * const encryptionKey = crypto.randomBytes(32).toString('base64');
   * await wrapper.enableEncryption(encryptionKey);
   * ```
   */
  enableEncryption(encryptionKey: string, publicKey?: string | undefined | null): void
  /** Disable encryption for ReasoningBank */
  disableEncryption(): void
  /** Check if encryption is enabled */
  isEncryptionEnabled(): boolean
  /**
   * Decrypt a trajectory by ID
   *
   * # Arguments
   * * `trajectory_id` - UUID of the trajectory to decrypt
   * * `decrypted_payload` - Decrypted JSON payload from HQC decryption
   *
   * # Returns
   * JSON string of the decrypted trajectory
   */
  decryptTrajectory(trajectoryId: string, decryptedPayload: string): string
  /**
   * Get encrypted payload for a trajectory (for HQC encryption in JavaScript)
   *
   * Returns the plaintext payload that should be encrypted with HQC
   */
  getTrajectoryPayload(trajectoryId: string): string | null
  /** Query similar trajectories by task */
  queryTrajectories(task: string, limit: number): string
  /** Reset reasoning bank (clear all learning) */
  resetLearning(): void
  /** Enable agent coordination with QuantumDAG */
  enableAgentCoordination(): Promise<void>
  /** Register a new agent in the coordination system */
  registerAgent(agentId: string, agentType: string): Promise<void>
  /** Register an agent operation in the coordination system */
  registerAgentOperation(agentId: string, operationId: string, affectedFiles: Array<string>): Promise<string>
  /** Check for conflicts with proposed operation */
  checkAgentConflicts(operationId: string, operationType: string, affectedFiles: Array<string>): Promise<string>
  /** Get agent statistics */
  getAgentStats(agentId: string): Promise<string>
  /** List all registered agents */
  listAgents(): Promise<string>
  /** Get coordination statistics */
  getCoordinationStats(): Promise<string>
  /** Get coordination tips (DAG tips) */
  getCoordinationTips(): Promise<Array<string>>
  /**
   * Generate a quantum fingerprint for an operation
   *
   * This method generates a quantum-resistant fingerprint using @qudag/napi-core
   * for fast integrity verification of JJ operations.
   *
   * # Arguments
   * * `operation_id` - The ID of the operation to fingerprint
   *
   * # Returns
   * The quantum fingerprint as a hex string
   *
   * # Example
   * ```javascript
   * const wrapper = new JJWrapper();
   * const fingerprint = await wrapper.generateOperationFingerprint(operationId);
   * ```
   */
  generateOperationFingerprint(operationId: string): Promise<string>
  /**
   * Verify an operation's quantum fingerprint
   *
   * Checks if the stored quantum fingerprint matches the current operation data.
   *
   * # Arguments
   * * `operation_id` - The ID of the operation to verify
   * * `fingerprint` - The expected fingerprint to verify against
   *
   * # Returns
   * `true` if the fingerprint is valid, `false` otherwise
   *
   * # Example
   * ```javascript
   * const isValid = await wrapper.verifyOperationFingerprint(operationId, fingerprint);
   * if (isValid) {
   *   console.log('Operation integrity verified!');
   * }
   * ```
   */
  verifyOperationFingerprint(operationId: string, fingerprint: string): Promise<boolean>
  /**
   * Get operation data for quantum fingerprint generation (helper method)
   *
   * Returns the serialized operation data that should be fingerprinted.
   * This is used by the JavaScript wrapper to call @qudag/napi-core.
   *
   * # Arguments
   * * `operation_id` - The ID of the operation
   *
   * # Returns
   * The operation data as a Buffer (Uint8Array in JS)
   */
  getOperationData(operationId: string): Array<number>
  /**
   * Update operation with quantum fingerprint
   *
   * Stores a quantum fingerprint for an operation.
   *
   * # Arguments
   * * `operation_id` - The ID of the operation
   * * `fingerprint` - The quantum fingerprint (hex string)
   */
  setOperationFingerprint(operationId: string, fingerprint: string): void
  /**
   * Sign an operation by ID
   *
   * Creates a quantum-resistant digital signature for the specified operation.
   *
   * # Arguments
   *
   * * `operation_id` - The operation ID to sign
   * * `secret_key` - The secret key in hex format
   * * `public_key` - The corresponding public key in hex format
   */
  signOperation(operationId: string, secretKey: string, publicKey: string): void
  /**
   * Verify an operation's signature by ID
   *
   * # Arguments
   *
   * * `operation_id` - The operation ID to verify
   *
   * # Returns
   *
   * `true` if signature is valid, `false` if invalid
   */
  verifyOperationSignature(operationId: string): boolean
  /**
   * Verify all operations in the log
   *
   * # Arguments
   *
   * * `public_key` - Optional public key to verify against
   *
   * # Returns
   *
   * JSON string with verification results: { total_signed, valid_count, invalid_count }
   */
  verifyAllOperations(publicKey?: string | undefined | null): string
  /**
   * Sign all unsigned operations
   *
   * # Arguments
   *
   * * `secret_key` - The secret key in hex format
   * * `public_key` - The corresponding public key in hex format
   *
   * # Returns
   *
   * Number of operations that were signed
   */
  signAllOperations(secretKey: string, publicKey: string): number
  /** Get count of signed operations */
  getSignedOperationsCount(): number
  /** Get count of unsigned operations */
  getUnsignedOperationsCount(): number
  /**
   * Verify signature chain integrity
   *
   * Verifies that all signed operations form a valid chain.
   *
   * # Returns
   *
   * `true` if chain is valid, `false` if broken
   */
  verifySignatureChain(): boolean
}
